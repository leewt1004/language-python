## 32.2 람다 표현식과 map, filter, reduce 함수 활용하기
""" 람다 표현식 작성 방법을 알아보았으니 이번에는 람다 표현식과 map, filter, reduce 함수를 함께 사용해보겠습니다. """




### 32.2.1  람다 표현식에 조건부 표현식 사용하기
"""
먼저 람다 표현식에서 조건부 표현식을 사용하는 방법을 알아보겠습니다.

lambda 매개변수들: 식1 if 조건식 else 식2
다음은 map을 사용하여 리스트 a에서 3의 배수를 문자열로 변환합니다.

"""
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list(map(lambda x : str(x) if x % 3 == 0 else x, a))            # print(list(map(lambda x: str(x) if x % 3 == 0 else x, a)))
"""
----- 코드 흐름 및 설명 -----

(1) lambda x : str(x) if x % 3 == 0 else x, a
    - lambda는 익명 함수를 정의합니다.
    - 이 함수는 입력값 x에 대해 다음 조건을 수행합니다:
    - x % 3 == 0: x가 3의 배수라면, 숫자 x를 문자열로 변환하여 반환합니다 (str(x)).
    - else x: 그렇지 않으면, 원래 값을 그대로 반환합니다.

(2) 설명
    map은 리스트의 요소를 각각 처리하므로 lambda의 반환값도 요소라야 합니다.
    여기서는 요소가 3의 배수일 때는 str(x)로 요소를 문자열로 만들어서 반환했고, 3의 배수가 아닐 때는 x로 요소를 그대로 반환했습니다.
    람다 표현식 안에서 조건부 표현식 if, else를 사용할 때는 :(콜론)을 붙이지 않습니다.
    일반적인 if, else와 문법이 다르므로 주의해야 합니다. 
    조건부 표현식은 식1 if 조건식 else 식2 형식으로 사용하며 식1은 조건식이 참일 때, 식2는 조건식이 거짓일 때 사용할 식입니다.
    특히 람다 표현식에서 if를 사용했다면 반드시 else를 사용해야 합니다. if만 사용하면 문법에러가 발생하므로 주의해야 합니다.
"""


"""
람다 표현식 안에서는 elif를 사용할 수 없습니다.
따라서 조건부 표현식은 식1 if 조건식1 else 식2 if 조건식2 else 식3 형식처럼 if를 연속으로 사용해야 합니다.
예를 들어 리스트에서 1은 문자열로 변환하고, 2는 실수로 변환, 3 이상은 10을 더하는 식은 다음과 같이 만듭니다.

lambda 매개변수들: 식1 if 조건식1 else 식2 if 조건식2 else 식3
"""
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list(map(lambda x : str(x) if x == 1 else float(x) if x == 2 else x + 10 ,a))
"""
----- 코드 흐름 및 설명 -----

(1) map()함수
    - 리스트 a의 각 요소 x에 대해 지어된 함수(lambda)를 적용합니다.

(2) lambda x
    - 각 요소를 어떻게 처리할지를 정의한 익명 함수입니다.

(3) if x == 1
    - 만약 x가 1이라면 숫자 x를 문자열로 바꿉니다. 만약 조건이 참이라면 이 값을 반환하고, 이후 조건들은 평가하지 않습니다.

(4) else float(x) if x == 2
    - 첫 번째 조건이 거짓일 때 실행되며, x가 2이면 x를 실수로 변환합니다.(float x)
    - 마찬가지로 조건이 참이면 이 값을 반환하고, 이후 조건들은 평가하지 않습니다.

(5) else x + 10
    - 두 조건이 모두 거짓이면 실행되며, x에 10을 더한 값을 반환합니다.

(6) 참고
    - else float(x) if x == 2
        · else if처럼 동작하는 부분에 float(x)라는 동작을 추가하여 한 줄로 압축된 삼항 연산자 안에서 조건에 따라 다른 작업을 지정한 것입니다.

별로 복잡하지 않은 조건인데도 알아보기가 힘듭니다.
이런 경우에는 억지로 람다 표현식을 사용하기 보다는 그냥 def로 함수를 만들고 if, elif, else를 사용하는 것을 권장합니다.
복잡하고 어렵게 코드를 작성하면 나중에 시간이 지나서 자기가 만든 코드인데도 못 알아보는 경우가 생깁니다.
코드는 길이가 조금 길어지더라도 알아보기 쉽게 작성하는 것이 좋습니다.

def f(x) :
    if x == 1:
        return str(x)
    elif x == 2 :
        return float(x)
    else :
        return x + 10

a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list(map(f ,a))
"""




### 32.2.2  map에 객체를 여러 개 넣기
"""
map은 리스트 등의 반복 가능한 객체를 여러 개 넣을 수도 있습니다. 다음은 두 리스트의 요소를 곱해서 새 리스트를 만듭니다.
이렇게 리스트 두 개를 처리할 때는 람다 표현식에서 lambda x, y: x * y처럼 매개변수를 두 개로 지정하면 됩니다.
그리고 map에 람다 표현식을 넣고 그다음에 리스트 두 개를 콤마로 구분해서 넣어줍니다.
즉, 람다 표현식의 매개변수 개수에 맞게 반복 가능한 객체도 콤마로 구분해서 넣어주면 됩니다.
"""
a = [1, 2, 3, 4, 5]
b = [2, 4, 6, 8, 10]
print(list(map(lambda x , y : x * y, a, b)))
"""
----- 코드 흐름 및 설명 -----

(1) list a, b
    - a와 b 리스트 정의

(2) map(lambda x, y: x * y, a, b)
    - lambda x, y: x * y는 두 값을 곱하는 작업을 정의한 익명 함수입니다.
    - map 함수가 두 리스트 a와 b의 같은 위치에 있는 요소(x와 y)를 하나씩 꺼냅니다.

(3) 설명
    이 코드는 리스트 a와 b의 각 요소를 곱해서 새로운 리스트를 만드는 코드입니다.
    같은 위치의 요소를 꺼내서 곱한 결과를 리스트로 반환한다고 기억하면 됩니다.
"""




### 32.2.3  filter 사용하기
"""
이번에는 filter를 사용해보겠습니다. filter는 반복 가능한 객체에서 특정 조건에 맞는 요소만 가져오는데, filter에 지정한 함수의 반환값이 True일 때만 해당 요소를 가져옵니다.
먼저 def로 함수를 만들어서 filter를 사용해보겠습니다. 다음은 리스트에서 5보다 크면서 10보다 작은 숫자를 가져옵니다.

filter(함수, 반복가능한객체)
"""
def f(x) :
    return x > 5 and x < 10

a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]
print(list(filter(f, a)))
"""
----- 코드 흐름 및 설명 -----

(1) def f(x) :
    return x > 5 and x < 10
    - 함수를 정의하고, 입력한 x가 5보다 크고 10보다 작은지 확인하는 함수로, 조건에 맞으면 True를 반환하고, 맞지 않으면 False를 반환합니다.

(2) a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]
    - 리스트 a정의

(3) list(filter(f, a))
    - filter(f, a)는 리스트의 각 요소들을 함수에 넣어봅니다.
    - f(x)가 True를 반환하는 요소만 필터링 하여 list로 변환합니다.

(4) 설명
    filter(f, a): 리스트 a에서 f(x)가 참인 값만 골라냅니다.
    조건: 값이 5보다 크고 10보다 작은 값만 포함.
    출력: [8, 7, 9].
    간리스트에서 원하는 조건에 맞는 값만 뽑아내는 코드입니다.
"""


""" 함수 f를 람다 표현식으로 만들어서 filter에 넣어보겠습니다."""
a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]
print(list(filter(lambda f: f > 5 and f < 10, a)))




### 32.2.4  reduce 사용하기
"""
마지막으로 reduce를 사용해보겠습니다. reduce는 반복 가능한 객체의 각 요소를 지정된 함수로 처리한 뒤 이전 결과와 누적해서 반환하는 함수입니다.
(reduce는 파이썬 3부터 내장 함수가 아닙니다. 따라서 functools 모듈에서 reduce 함수를 가져와야 합니다)
다음은 리스트에 저장된 요소를 순서대로 더한 뒤 누적된 결과를 반환합니다.

from functools import reduce
reduce(함수, 반복가능한객체)
"""
def f(x, y) :
    return x + y

a = [1, 2, 3, 4, 5]
from functools import reduce
print(reduce(f, a))
"""
----- 코드 흐름 및 설명 -----

(1) def f(x, y) :
        return x + y
    - 함수를 정의하고, 입력한 x, y를 서로 더해줍니다.

(2) a = [1, 2, 3, 4, 5]
    - 리스트 a정의

(3) from functools import reduce
    - functools 모듈에서 reduce 함수를 사용합니다.
    - reduce(f, a)는 리스트 a의 요소를 순차적으로 함수 f에 넣어 처리합니다.
    - 첫 두 요소 1과 2를 함수 f로 더한 다음, 그 결과를 다음 요소 3과 다시 더합니다.
    - 이 과정을 리스트의 끝까지 반복합니다.
"""


""" 이제 함수 f를 람다 표현식으로 만들어서 reduce에 넣어보겠습니다.
lambda x, y: x + y와 같이 매개변수 x, y를 지정한 뒤 x와 y를 더한 결과를 반환하도록 만들었습니다.
"""
a = [1, 2, 3, 4, 5]
from functools import reduce
print(reduce(lambda x, y : x + y, a))



"""
지금까지 람다 표현식으로 익명 함수를 만들고, map, filter, reduce와 응용하는 방법을 알아보았습니다.
람다 표현식은 간단하게 함수를 만들 때 자주 사용합니다. 그러므로 람다 표현식은 꼭 익혀 두는 것이 좋습니다.
"""




#### 참고 : map, filter, reduce와 리스트 표현식
"""
리스트(딕셔너리, 세트) 표현식으로 처리할 수 있는 경우에는 map, filter와 람다 표현식 대신 리스트 표현식을 사용하는 것이 좋습니다.
리스트 표현식이 좀 더 알아보기 쉽고 속도도 더 빠릅니다.
또한, for, while 반복문으로 처리할 수 있는 경우에도 reduce 대신 for, while을 사용하는 것이 좋습니다.
왜냐하면 reduce는 코드가 조금만 복잡해져도 의미하는 바를 한 눈에 알아보기가 힘들기 때문입니다.
이러한 이유로 파이썬 3부터는 reduce가 내장 함수에서 제외되었습니다.
"""



""" list(filter(lambda x: x > 5 and x < 10, a))는 다음과 같이 리스트 표현식으로도 만들 수 있습니다. """
a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]
print([i for i in a if i > 5 and i < 10])


""" reduce(lambda x, y: x + y, a)는 다음과 같이 for 반복문으로 표현할 수 있습니다. """
a = [1, 2, 3, 4, 5]
x = a[0]
for i in range(len(a) -1) :
    x = x + a[i + 1]

print(x)
"""
----- 코드 흐름 및 설명 -----

(1) a = [1, 2, 3, 4, 5]
    - 리스트 a정의

(2) x = a[0]
    - x = a[0]: 리스트의 첫 번째 요소(1)를 변수 x에 저장합니다. / 초기값 x = 1.

(3) for i in range(len(a) -1) :
        x = x + a[i + 1]
    - 첫 번째 반복
        (i = 0):
        a[i + 1] = a[1] = 2
        x = x + a[1] → x = 1 + 2 = 3
    
    - 두 번째 반복
        (i = 1):
        a[i + 1] = a[2] = 3
        x = x + a[2] → x = 3 + 3 = 6

    - 세 번째 반복
        (i = 2):
        a[i + 1] = a[3] = 4
        x = x + a[3] → x = 6 + 4 = 10
    
    - 네 번째 반복
        (i = 3):
        a[i + 1] = a[4] = 5
        x = x + a[4] → x = 10 + 5 = 15

(4) len(a)-1의 이유
    - 초기값 x = a[0]에 첫 번째 값(1)이 들어있기 때문에, 반복문에서 a[i + 1]로 리스트의 나머지 값(2, 3, 4, 5)을 차례로 더합니다.
    - 결과적으로 리스트의 모든 값(1, 2, 3, 4, 5)이 포함되어 합산됩니다.
"""
